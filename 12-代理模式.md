# 代理模式

## 模式概述

定义: 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问

* 引入一个新的代理对象
* 代理对象在客户端对象和目标对象之间起到中介的作用
* 去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务

## 模式结构与实现

![代理模式结构图](picture\ProxyPattern.png)

三个角色:

* Subject 抽象主题角色
* Proxy 代理主题角色
* RealSubject 真实主题角色

抽象主题类:

```java
public abstract class Subject {
	public abstract void request();
}
```

真实主题类:

```java
public class RealSubject extends Subject{
	public void request() {
        //业务方法具体实现代码
    }
}
```

代理主题类:

```java
public class Proxy extends Subject {
    private RealSubject realSubject = new RealSubject();  //维持一个对真实主题对象的引用 
    public void preRequest() {
        …...
    }
 
    public void request() {
        preRequest();
        realSubject.request();  //调用真实主题对象的方法
        postRequest();
    }
 
    public void postRequest() {
        ……
    }
}
```



## 模式应用实例

## 模式的优/缺点与适用环境

优点: 

* 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
* 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性
* 远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率
* 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销
* 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间
* 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限

缺点: 

* 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理）
* 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）

适用环境: 

* 当客户端对象需要访问远程主机中的对象时可以使用远程代理
* 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理
* 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理
* 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理
* 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理